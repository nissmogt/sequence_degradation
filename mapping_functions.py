def map_indices(seq_i, start_i, end_i,
                seq_j, start_j, end_j, gaps=("-", ".")):
    """
    Compute index mapping between positions in two
    aligned sequences

    Parameters
    ----------
    seq_i : str
        First aligned sequence
    start_i : int
        Index of first position in first sequence
    end_i : int
        Index of last position in first sequence
        (used for verification purposes only)
    seq_j : str
        Second aligned sequence
    start_j : int
        Index of first position in second sequence
    end_j : int
        Index of last position in second sequence
        (used for verification purposes only)

    Returns
    -------
    pandas.DataFrame
        Mapping table containing assignment of

        1. index in first sequence (i)
        2. symbol in first sequence (A_i)
        3. index in second sequence (j)
        4. symbol in second sequence (A_j)
    """
    import numpy as np
    import pandas as pd
    NA = np.nan
    pos_i = start_i
    pos_j = start_j
    mapping = []

    for i, (res_i, res_j) in enumerate(zip(seq_i, seq_j)):
        # Do we match two residues, or residue and a gap?
        # if matching two residues, store 1 to 1 mapping.
        # Store positions as strings, since pandas cannot
        # handle nan values in integer columns
        if res_i not in gaps and res_j not in gaps:
            mapping.append([str(pos_i), res_i, str(pos_j), res_j])
        elif res_i not in gaps:
            mapping.append([str(pos_i), res_i, NA, NA])
        elif res_j not in gaps:
            mapping.append([NA, NA, str(pos_j), res_j])

        # adjust position in sequences if we saw a residue
        if res_i not in gaps:
            pos_i += 1

        if res_j not in gaps:
            pos_j += 1

    # assert pos_i - 1 == end_i and pos_j - 1 == end_j

    return pd.DataFrame(
        mapping, columns=["i", "A_i", "j", "A_j"]
    )


def align_dca2pdb(msa_name, pdbseq, msaseq):
    """
    Computes alignments of individual msa sequences to pdb sequences - only for dimer sequences.
    Some code taken from
    https://github.com/bsir/dca-frustratometer/blob/master/dca_frustratometer.py
    NOTE: uses EV coupling mapping to map # TODO: code this myself
    :param msa_name:
    :param pdbseq: PDB seq string
    :param msaseq: MSA seq string
    :return:
    """
    import numpy as np
    from Bio import pairwise2
    print("(map_dca2pdb)\taligning dca sequence to pdb coord sequence...")

    # need to penalize for opening and adding gaps otherwise mapping is off (s param {-.5,-.1})
    assert len(msaseq) > 1
    alignments_1 = pairwise2.align.globalxs(pdbseq[0], msaseq[0], -.5, -.1)
    alignments_2 = pairwise2.align.globalxs(pdbseq[1], msaseq[1], -.5, -.1)
    # print(pairwise2.format_alignment(*alignments_1[0], full_sequences=True))
    # print(pairwise2.format_alignment(*alignments_2[0], full_sequences=True))

    map_1 = map_indices(alignments_1[0][0], 1, 0, alignments_1[0][1], 1, 0)
    map_2 = map_indices(alignments_2[0][0], 1 + len(pdbseq[0]), 0,
                             alignments_2[0][1], 1 + len(msaseq[0]), 0)
    map_pdb_dca = map_1.append(map_2)
    map_pdb_dca = map_pdb_dca.rename(columns={"i": "pdb_i", "A_i": "pdb_res", "j": "dca_i", "A_j": "dca_res"})

    outfile = "ref_map_{}.txt".format(msa_name.strip(".fasta"))
    np.savetxt(outfile, map_pdb_dca, header="pdb_i\tpdb_res\tdca_i\tdca_res", fmt="%s\t%s\t%s\t%s", comments='')
    print("(map_dca2pdb)\tWrote {}".format(outfile))

    map_pdb_dca = map_pdb_dca.dropna()
    map_dca2pdb_dict = dict(zip(map_pdb_dca["dca_i"], map_pdb_dca["pdb_i"]))
    return map_dca2pdb_dict


def apply_map(array, map_pdb_dca, dist=False):
    """
    Map DCA indices to PDB. Dependes on reference map.
    :param array: NumPy array, Array of values to map. Columns should be: i, j, fn_apc, fn
    :param map_pdb_dca: Dict, reference mappings generated by align_dca2pdb function
    :return: NumPy array, the columns are as follows: i, j, fn_apc, fn, original_i, original_j
    """
    import numpy as np
    print("(apply_map)")

    map_dca_list = []
    if not dist:
        for i, j, s1, s2, s3 in array:
        # for i, j, s1, s2 in array:
            i = int(i)
            j = int(j)
            # if i in map_pdb_dca.keys() and j in map_pdb_dca.keys():
            if str(i) in map_pdb_dca.keys() and str(j) in map_pdb_dca.keys():
                map_index_i = int(map_pdb_dca[str(i)])
                map_index_j = int(map_pdb_dca[str(j)])
                # map_index_i = int(map_pdb_dca[i])
                # map_index_j = int(map_pdb_dca[j])
                if map_index_i and map_index_j >= 0:
                    # map_dca_list.append([map_index_i, map_index_j, s1, s2, i, j])
                    map_dca_list.append([map_index_i, map_index_j, s1, s2, s3, i, j])
    else:
        for i, j, d in array:
            i = int(i)
            j = int(j)
            # if i in map_pdb_dca.keys() and j in map_pdb_dca.keys():
            if str(i) in map_pdb_dca.keys() and str(j) in map_pdb_dca.keys():
                map_index_i = int(map_pdb_dca[str(i)])
                map_index_j = int(map_pdb_dca[str(j)])
                # map_index_i = int(map_pdb_dca[i])
                # map_index_j = int(map_pdb_dca[j])
                if map_index_i and map_index_j >= 0:
                    map_dca_list.append([map_index_i, map_index_j, d])

    return np.array(map_dca_list)


def apply_map_mfdca(array, map_pdb_dca, dist=False):
    """
    Map DCA indices to PDB. Dependes on reference map.
    :param array: NumPy array, Array of values to map. Columns should be: i, j, fn_apc, fn
    :param map_pdb_dca: Dict, reference mappings generated by align_dca2pdb function
    :param dist:
    :return: NumPy array, the columns are as follows: i, j, fn_apc, fn, original_i, original_j
    """
    import numpy as np
    print("(apply_map)")

    map_dca_list = []
    if not dist:
        for i, j, s1, s2, s3 in array:
            i = int(i)
            j = int(j)
            # if i in map_pdb_dca.keys() and j in map_pdb_dca.keys():
            if str(i) in map_pdb_dca.keys() and str(j) in map_pdb_dca.keys():
                map_index_i = int(map_pdb_dca[str(i)])
                map_index_j = int(map_pdb_dca[str(j)])
                # map_index_i = int(map_pdb_dca[i])
                # map_index_j = int(map_pdb_dca[j])
                if map_index_i and map_index_j >= 0:
                    map_dca_list.append([map_index_i, map_index_j, s1, s2, s3, i, j])
    else:
        for i, j, d in array:
            i = int(i)
            j = int(j)
            # if i in map_pdb_dca.keys() and j in map_pdb_dca.keys():
            if str(i) in map_pdb_dca.keys() and str(j) in map_pdb_dca.keys():
                map_index_i = int(map_pdb_dca[str(i)])
                map_index_j = int(map_pdb_dca[str(j)])
                # map_index_i = int(map_pdb_dca[i])
                # map_index_j = int(map_pdb_dca[j])
                if map_index_i and map_index_j >= 0:
                    map_dca_list.append([map_index_i, map_index_j, d])

    return np.array(map_dca_list)


def map_dict(msa_name):
    import pandas as pd
    import numpy as np
    from get_region import get_dca_indices
    sifts_table_file = "databases/sifts/pdb_chain_uniprot_plus.csv"
    s = pd.read_csv(sifts_table_file, comment="#")
    pdbid = msa_name[:4].lower()
    chain_1 = msa_name.split("_")[1]
    chain_2 = msa_name.split("_")[3]

    pdb_start_chain_1 = s.query("pdb_id == @pdbid and pdb_chain == @chain_1").coord_start.values
    pdb_start_chain_2 = s.query("pdb_id == @pdbid and pdb_chain == @chain_2").coord_start.values
    pdb_end_chain_1 = s.query("pdb_id == @pdbid and pdb_chain == @chain_1").coord_end.values
    pdb_end_chain_2 = s.query("pdb_id == @pdbid and pdb_chain == @chain_2").coord_end.values

    uniprot_start_chain_1 = s.query("pdb_id == @pdbid and pdb_chain == @chain_1").uniprot_start.values
    uniprot_end_chain_1 = s.query("pdb_id == @pdbid and pdb_chain == @chain_1").uniprot_end.values
    uniprot_start_chain_2 = s.query("pdb_id == @pdbid and pdb_chain == @chain_2").uniprot_start.values
    uniprot_end_chain_2 = s.query("pdb_id == @pdbid and pdb_chain == @chain_2").uniprot_end.values

    # pdb
    pdb_start_chain_1 = ([int(i) for i in pdb_start_chain_1])
    pdb_end_chain_1 = ([int(i) for i in pdb_end_chain_1])
    # add last index of end index + 1 for chain 2
    pdb_start_chain_2 = ([(int(i) + pdb_end_chain_1[-1] + 1) for i in pdb_start_chain_2])
    pdb_end_chain_2 = ([(int(i) + pdb_end_chain_1[-1] + 1) for i in pdb_end_chain_2])

    # uniprot
    uniprot_start_chain_1 = ([int(i) for i in uniprot_start_chain_1])
    uniprot_end_chain_1 = ([int(i) for i in uniprot_end_chain_1])
    # add last index of end index + 1 for chain 2
    uniprot_start_chain_2 = ([(int(i) + uniprot_end_chain_1[-1] + 1) for i in uniprot_start_chain_2])
    uniprot_end_chain_2 = ([(int(i) + uniprot_end_chain_1[-1] + 1) for i in uniprot_end_chain_2])

    pdb_start_indices = pdb_start_chain_1 + pdb_start_chain_2
    pdb_end_indices = pdb_end_chain_1 + pdb_end_chain_2
    uniprot_start_indices = uniprot_start_chain_1 + uniprot_start_chain_2
    uniprot_end_indices = uniprot_end_chain_1 + uniprot_end_chain_2

    pdb_indices = make_indices(pdb_start_indices, pdb_end_indices)
    # pdb_indices = range(1, len(pdb_indices))
    uniprot_indices = make_indices(uniprot_start_indices, uniprot_end_indices)

    dca_indices = get_dca_indices(msa_name)
    uni2pdb = dict(zip(uniprot_indices, pdb_indices))
    dca2uni = dict(zip(dca_indices, uniprot_indices))
    dca2pdb = dict(zip(dca_indices, pdb_indices))
    pdb2uni = dict(zip(pdb_indices, uniprot_indices))
    # print(dca2pdb)
    return uni2pdb, dca2uni, dca2pdb, pdb2uni


def make_indices(indices_1, indices_2):
    import numpy as np
    x = []
    for i in range(len(indices_1)):
        x.append(np.array(range(indices_1[i], indices_2[i])))
    return np.concatenate(x)


